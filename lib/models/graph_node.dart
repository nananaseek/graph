import 'package:flutter/material.dart';
import '../core/constants.dart';
import '../core/service_locator.dart';
import '../services/graph_data_service.dart';

class GraphNode {
  String id;
  Offset position;
  Offset velocity;
  String label;

  /// Display name for side panel
  String name;

  /// Money generated by this node specifically
  double selfGeneratedMoney;

  /// Recursive total money: self + all descendants
  // Note: accessing service locator involves a dependency, but requested by task structure.
  double get totalGeneratedMoney {
    try {
      if (childrenIds.isEmpty) return selfGeneratedMoney;

      final graphDataService = getIt<GraphDataService>();
      double sum = selfGeneratedMoney;
      for (final childId in childrenIds) {
        final child = graphDataService.getNode(childId);
        if (child != null) {
          sum += child.totalGeneratedMoney;
        }
      }
      return sum;
    } catch (e) {
      return selfGeneratedMoney;
    }
  }

  /// Number of connections
  int connectionCount;

  /// IDs of attached nodes
  List<String> attachedNodeIds;

  /// Parent node ID (null = master / root node)
  String? parentId;

  /// Children (slave) node IDs
  List<String> childrenIds;

  /// Whether this is a master (root-level) node
  bool get isMaster => parentId == null;

  double mass;
  double radius;

  double appearanceScale;

  TextPainter? textPainter;
  double _lastMass = -1;

  GraphNode({
    required this.id,
    required this.position,
    required this.label,
    this.name = '',
    this.velocity = Offset.zero,
    this.mass = 1.0,
    this.radius = 18.0,
    this.appearanceScale = 0.0,
    this.selfGeneratedMoney = 0.0,
    this.connectionCount = 0,
    this.parentId,
    List<String>? attachedNodeIds,
    List<String>? childrenIds,
  }) : attachedNodeIds = attachedNodeIds ?? [],
       childrenIds = childrenIds ?? [] {
    if (name.isEmpty) name = label;
    _lastMass = mass;
    _updateTextPainter();
  }

  void _updateTextPainter() {
    textPainter = TextPainter(
      text: TextSpan(
        text: label,
        style: TextStyle(
          color: Colors.white,
          fontSize: 11 + (mass * 1.5),
          fontWeight: FontWeight.w500,
          shadows: const [Shadow(color: Colors.black54, offset: Offset(1, 1))],
        ),
      ),
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    )..layout();
  }

  void updateSize(int degree) {
    const baseRadius = 18.0;
    const baseMass = 1.0;

    radius = baseRadius + (degree * 1.1);
    mass = baseMass + (degree * AppConstants.connectionMassModifier);
    connectionCount = degree;

    if (mass != _lastMass) {
      _lastMass = mass;
      _updateTextPainter();
    }
  }

  Map<String, dynamic> toJson({required Map<String, GraphNode> allNodes}) {
    final Map<String, dynamic> data = {
      'id': id,
      'position': {'dx': position.dx, 'dy': position.dy},
      'label': label,
      'name': name,
      'selfGeneratedMoney': selfGeneratedMoney,
      'mass': mass,
      'radius': radius,
      'parentId': parentId,
      'attachedNodeIds': attachedNodeIds,
    };

    if (childrenIds.isNotEmpty) {
      data['children'] = childrenIds
          .map((childId) => allNodes[childId]?.toJson(allNodes: allNodes))
          .whereType<Map<String, dynamic>>()
          .toList();
    }

    return data;
  }

  factory GraphNode.fromJson(Map<String, dynamic> json) {
    return GraphNode(
      id: json['id'] as String,
      position: Offset(
        (json['position']['dx'] as num).toDouble(),
        (json['position']['dy'] as num).toDouble(),
      ),
      label: json['label'] as String,
      name: json['name'] as String? ?? '',
      selfGeneratedMoney: (json['selfGeneratedMoney'] as num).toDouble(),
      mass: (json['mass'] as num).toDouble(),
      radius: (json['radius'] as num).toDouble(),
      parentId: json['parentId'] as String?,
      attachedNodeIds: (json['attachedNodeIds'] as List<dynamic>?)
          ?.map((e) => e as String)
          .toList(),
      childrenIds: [], // Will be populated during flattening
    );
  }
}
